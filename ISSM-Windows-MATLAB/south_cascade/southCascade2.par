%estimated_base=load('Data/estimated_base.mat').estimated_base;
surface=load('Data/surface2.mat').elevationData;
x=load('Data/x2.mat').x;
y=load('Data/y2.mat').y;

pos17=find(surface>3000);
surface(pos17)=NaN;

velx_coords=ncread('../../Data/SouthCascadeData/ALA_G0120_1985.nc','x');
vely_coords=flip(ncread('../../Data/SouthCascadeData/ALA_G0120_1985.nc','y'));
velx=flipud(ncread('../../Data/SouthCascadeData/ALA_G0120_1985.nc','vx')');
vely=flipud(ncread('../../Data/SouthCascadeData/ALA_G0120_1985.nc','vy')');
vel=flipud(ncread('../../Data/SouthCascadeData/ALA_G0120_1985.nc','v')');

pos12=find(isnan(velx));
velx(pos12)=0;
pos13=find(isnan(vely));
vely(pos13)=0;
pos14=find(isnan(vel));
vel(pos14)=0;

md.initialization.vx=InterpFromGridToMesh(velx_coords,vely_coords,velx,md.mesh.x,md.mesh.y,0);
md.initialization.vy=InterpFromGridToMesh(velx_coords,vely_coords,vely,md.mesh.x,md.mesh.y,0);
md.initialization.vz=zeros(md.mesh.numberofvertices,1);
md.initialization.vel=InterpFromGridToMesh(velx_coords,vely_coords,vel,md.mesh.x,md.mesh.y,0);

md.geometry.surface=InterpFromGridToMesh(x,y,surface,md.mesh.x,md.mesh.y,0);
%grad_x = gradient(md.geometry.surface, 1);  % Approximate gradient in x-direction
%grad_y = gradient(md.geometry.surface')';
%slope_magnitude = sqrt(grad_x.^2 + grad_y.^2);
%thickness = (md.initialization.vel ./ (1e-24 * (917 * 9.81 * slope_magnitude).^3)).^(1/3);
[bed_elev, R] = geotiffread('Data/kriging_bed_topo.tif');
bed_elev=double(bed_elev);
x = R.XWorldLimits(1) + (0:size(bed_elev, 2) - 1) * R.CellExtentInWorldX;
y = flip(R.YWorldLimits(2) - (0:size(bed_elev, 1) - 1) * R.CellExtentInWorldY);
bed_elev=flipud(bed_elev);
md.geometry.base=InterpFromGridToMesh(x,y,bed_elev,md.mesh.x,md.mesh.y,0);
pos9=find(isnan(md.geometry.base));
md.geometry.base(pos9)=0;
pos10=find(isinf(md.geometry.base));
md.geometry.base(pos10)=200;
pos14=find(md.geometry.base>md.geometry.surface);
md.geometry.base(pos14)=md.geometry.surface(pos14);
md.geometry.thickness=md.geometry.surface-md.geometry.base;
pos15=find(md.geometry.thickness>200);
md.geometry.thickness(pos15)=200;
md.geometry.base=md.geometry.surface-md.geometry.thickness;
% Set minimum thickness to avoid instability
pos_invalid = find(md.geometry.thickness <= 0);
md.geometry.thickness(pos_invalid) = 1; % Set a small positive value
md.geometry.base(pos_invalid) = md.geometry.surface(pos_invalid) - md.geometry.thickness(pos_invalid);


md.initialization.pressure=md.materials.rho_ice*md.constants.g*md.geometry.thickness;
surface_temperature = 263.15; % Temperature at the surface, in °C
geothermal_gradient = 273.17; % Temperature increase per meter, in °C/m

depth = md.geometry.thickness; % Depth from surface (you may need to adjust based on model)
md.initialization.temperature = surface_temperature + geothermal_gradient * depth;

md.materials.rheology_n=3*ones(md.mesh.numberofelements,1);
%md.materials.rheology_B=paterson(md.initialization.temperature);

%TEMPORARY MASS BALANCE
md.smb.mass_balance = ones(md.mesh.numberofvertices, 1);

md.friction.coefficient=10*ones(md.mesh.numberofvertices,1);
md.friction.p=ones(md.mesh.numberofelements,1);
md.friction.q=ones(md.mesh.numberofelements,1);
pos_invalid = find(isnan(md.friction.coefficient) | md.friction.coefficient < 1);
md.friction.coefficient(pos_invalid) = 10; % Set to default
pos_invalid = find(isnan(md.friction.coefficient) | md.friction.coefficient <= 0);
md.friction.coefficient(pos_invalid) = 10; % Set a default friction coefficient
md.friction.p = ones(md.mesh.numberofelements, 1);
md.friction.q = ones(md.mesh.numberofelements, 1);


md.inversion=m1qn3inversion();
md.inversion.vx_obs=md.initialization.vx;
md.inversion.vy_obs=md.initialization.vy;
md.inversion.vel_obs=md.initialization.vel;

md.basalforcings.floatingice_melting_rate = zeros(md.mesh.numberofvertices,1);
md.basalforcings.groundedice_melting_rate = zeros(md.mesh.numberofvertices,1);
md.masstransport.spcthickness = NaN*ones(md.mesh.numberofvertices,1);

%NEED TO SET ICE BOUNDARY TO 0, NEED TO CALCULATE ICE BOUNDARY
md.mask.ocean_levelset = ones(md.mesh.numberofvertices, 1);
md.mask.ice_levelset = ones(md.mesh.numberofvertices, 1); % Default ice-covered
no_ice_vertices = find(md.geometry.thickness == 0); % Points with zero thickness
md.mask.ice_levelset(no_ice_vertices) = -1; % Set these points as ice-free

md.basalforcings.geothermalflux=zeros(md.mesh.numberofvertices,1);

md.stressbalance.spcvx = NaN(md.mesh.numberofvertices, 1);
md.stressbalance.spcvy = NaN(md.mesh.numberofvertices, 1);
boundary_nodes = find(md.geometry.thickness==0); % Replace with your boundary condition logic
md.stressbalance.spcvx(boundary_nodes) = 0; % Constrain x-velocity to 0
md.stressbalance.spcvy(boundary_nodes) = 0; % Constrain y-velocity to 0
md.stressbalance.spcvz = NaN(md.mesh.numberofvertices, 1);
if isempty(md.stressbalance.spcvx) || any(isnan(md.stressbalance.spcvx))
    md.stressbalance.spcvx = NaN(md.mesh.numberofvertices, 1);
end
if isempty(md.stressbalance.spcvy) || any(isnan(md.stressbalance.spcvy))
    md.stressbalance.spcvy = NaN(md.mesh.numberofvertices, 1);
end

md.stressbalance.referential = zeros(md.mesh.numberofvertices, 6);
md.stressbalance.loadingforce = zeros(md.mesh.numberofvertices, 3);
basal_vertices = find(md.mask.ocean_levelset ==1); 

% Set referential to NaN for basal vertices of grounded ice
md.stressbalance.referential(basal_vertices, :) = NaN;