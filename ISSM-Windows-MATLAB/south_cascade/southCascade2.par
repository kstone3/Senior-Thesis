estimated_base=load('Data/estimated_base.mat').estimated_base;
surface=load('Data/surface.mat').elevationData;
x=load('Data/x.mat').x;
y=load('Data/y.mat').y;

velx_coords=ncread('../../Data/SouthCascadeData/ALA_G0120_1985.nc','x');
vely_coords=flip(ncread('../../Data/SouthCascadeData/ALA_G0120_1985.nc','y'));
velx=flipud(ncread('../../Data/SouthCascadeData/ALA_G0120_1985.nc','vx')');
vely=flipud(ncread('../../Data/SouthCascadeData/ALA_G0120_1985.nc','vy')');
vel=flipud(ncread('../../Data/SouthCascadeData/ALA_G0120_1985.nc','v')');

pos12=find(isnan(velx));
velx(pos12)=0;
pos13=find(isnan(vely));
vely(pos13)=0;
pos14=find(isnan(vel));
vel(pos14)=0;

md.initialization.vx=InterpFromGridToMesh(velx_coords,vely_coords,velx,md.mesh.x,md.mesh.y,0);
md.initialization.vy=InterpFromGridToMesh(velx_coords,vely_coords,vely,md.mesh.x,md.mesh.y,0);
md.initialization.vz=zeros(md.mesh.numberofvertices,1);
md.initialization.vel=InterpFromGridToMesh(velx_coords,vely_coords,vel,md.mesh.x,md.mesh.y,0);

md.geometry.surface=InterpFromGridToMesh(x,y,surface,md.mesh.x,md.mesh.y,0);
%grad_x = gradient(md.geometry.surface, 1);  % Approximate gradient in x-direction
%grad_y = gradient(md.geometry.surface')';
%slope_magnitude = sqrt(grad_x.^2 + grad_y.^2);
%thickness = (md.initialization.vel ./ (1e-24 * (917 * 9.81 * slope_magnitude).^3)).^(1/3);
[bed_elev, R] = geotiffread('Data/kriging_bed_topo.tif');
bed_elev=double(bed_elev);
x = R.XWorldLimits(1) + (0:size(bed_elev, 2) - 1) * R.CellExtentInWorldX;
y = flip(R.YWorldLimits(2) - (0:size(bed_elev, 1) - 1) * R.CellExtentInWorldY);
bed_elev=flipud(bed_elev);
md.geometry.base=InterpFromGridToMesh(x,y,bed_elev,md.mesh.x,md.mesh.y,0);
pos9=find(isnan(md.geometry.base));
md.geometry.base(pos9)=0;
pos10=find(isinf(md.geometry.base));
md.geometry.base(pos10)=200;
pos14=find(md.geometry.base>md.geometry.surface);
md.geometry.base(pos14)=md.geometry.surface(pos14);
md.geometry.thickness=md.geometry.surface-md.geometry.base;
pos15=find(md.geometry.thickness>1000);
md.geometry.thickness(pos15)=1000;
md.geometry.base=md.geometry.surface-md.geometry.thickness;

md.initialization.pressure=md.materials.rho_ice*md.constants.g*md.geometry.thickness;
surface_temperature = 263.15; % Temperature at the surface, in °C
geothermal_gradient = 273.17; % Temperature increase per meter, in °C/m

depth = md.geometry.thickness; % Depth from surface (you may need to adjust based on model)
md.initialization.temperature = surface_temperature + geothermal_gradient * depth;

md.materials.rheology_n=3*ones(md.mesh.numberofelements,1);
%md.materials.rheology_B=paterson(md.initialization.temperature);

%TEMPORARY MASS BALANCE
md.smb.mass_balance = ones(md.mesh.numberofvertices, 1);

md.friction.coefficient=10*ones(md.mesh.numberofvertices,1);
md.friction.p=ones(md.mesh.numberofelements,1);
md.friction.q=ones(md.mesh.numberofelements,1);

md.inversion=m1qn3inversion();
md.inversion.vx_obs=md.initialization.vx;
md.inversion.vy_obs=md.initialization.vy;
md.inversion.vel_obs=md.initialization.vel;

md.basalforcings.floatingice_melting_rate = zeros(md.mesh.numberofvertices,1);
md.basalforcings.groundedice_melting_rate = zeros(md.mesh.numberofvertices,1);
md.masstransport.spcthickness = NaN*ones(md.mesh.numberofvertices,1);

%NEED TO SET ICE BOUNDARY TO 0, NEED TO CALCULATE ICE BOUNDARY
md.mask.ocean_levelset=-1*ones(md.mesh.numberofvertices,1);
md.mask.ice_levelset=1*ones(md.mesh.numberofvertices,1);

md.basalforcings.geothermalflux=zeros(md.mesh.numberofvertices,1);

md.stressbalance.spcvx = NaN(md.mesh.numberofvertices, 1);
md.stressbalance.spcvy = NaN(md.mesh.numberofvertices, 1);
md.stressbalance.spcvz = NaN(md.mesh.numberofvertices, 1);
md.stressbalance.referential = zeros(md.mesh.numberofvertices, 6);
md.stressbalance.loadingforce = zeros(md.mesh.numberofvertices, 3);
basal_vertices = find(md.mask.ocean_levelset ==1); 

% Set referential to NaN for basal vertices of grounded ice
md.stressbalance.referential(basal_vertices, :) = NaN;